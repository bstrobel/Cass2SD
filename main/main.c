/*
* main_ff_avr.c
*
* Created: 29.04.2017 12:44:25
*  Author: Bernd
*/
#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/sfr_defs.h>
#include <avr/sleep.h>
#include <avr/power.h>
#define __PROG_TYPES_COMPAT__
#include <avr/pgmspace.h>
#include <string.h>
#include <util/delay.h>
#include <stdbool.h>
#include "../ff_avr/xitoa.h"
#include "../ff_avr/ff.h"
#include "../ff_avr/diskio.h"
#include "../lcd/lcd.h"
#include "debounced_keys.h"
#include "format.h"

#define START_STOP_KEY 0
#define ROTARY_A START_STOP_KEY + 1
#define ROTARY_B ROTARY_A + 1
#define TIMER_OVF_MONITOR_PORT PORTD
#define TIMER_OVF_MONITOR_DDR DDRD
#define TIMER_OVF_MONITOR_BIT PORTD0 //Pin 2 for ATMega328P
#define CASS_OUT_PORT PORTD
#define CASS_OUT_DDR DDRD
#define CASS_OUT_PIN PORTD1 //Pin 3 for ATMega328P

typedef enum {STAY=0, UP, DOWN} DIRECTION;
typedef enum {SPACE=0, ONE, ZERO} BIT_TYPE;
typedef enum {DONE=0, FIRST_HALF, SECOND_HALF} SEND_STATE;
#define SEND_BUF_SIZE 130

volatile DIRECTION display_task = STAY;
volatile bool select_key_pressed;
volatile SEND_STATE send_state;
uint8_t buf[SEND_BUF_SIZE]; //send buffer
uint8_t* start_buf_ptr = buf;

DWORD sect = 0;
DSTATUS init_stat = STA_NOINIT;
DIR Dir;			/* Directory object */
FILINFO Finfo;
FIL fhdl;
FRESULT fr;
FATFS FatFs;		/* File system object for each logical drive */
uint16_t dir_idx = 0;

static void put_rc (FRESULT rc)
{
	const prog_char *p;
	static const prog_char str[] =
	"OK\0DISK_ERR\0INT_ERR\0NOT_READY\0NO_FILE\0NO_PATH\0INVALID_NAME\0"
	"DENIED\0EXIST\0INVALID_OBJECT\0WRITE_PROTECTED\0INVALID_DRIVE\0"
	"NOT_ENABLED\0NO_FILE_SYSTEM\0MKFS_ABORTED\0TIMEOUT\0LOCKED\0"
	"NOT_ENOUGH_CORE\0TOO_MANY_OPEN_FILES\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
		while(pgm_read_byte_near(p++));
	}
	lcd_clrscr();
	xprintf(PSTR("rc=%u"), rc);
	lcd_gotoxy(0,1);
	xprintf(PSTR("FR_%S"), p);
}

ISR(TIMER0_COMPA_vect)
{
	TIMER_OVF_MONITOR_PORT |= _BV(TIMER_OVF_MONITOR_BIT);
	switch(send_state)
	{
		case FIRST_HALF:
			CASS_OUT_PORT &= ~(_BV(CASS_OUT_PIN));
			send_state = SECOND_HALF;
			break;
		case SECOND_HALF:
		case DONE:
			send_state = DONE;
			TCCR0B = 0; // stop timer
			TCNT0 = 0;
			TIMSK0 = 0; //disallow Timer0 interrupts
			break;
		default:
			break;
	}
	TIMER_OVF_MONITOR_PORT &= ~_BV(TIMER_OVF_MONITOR_BIT);
}

static void timer0_init()
{
	TCCR0A = _BV(WGM01); // CTC mode -> TOP is OCR0A
	CASS_OUT_DDR |= _BV(CASS_OUT_PIN); // Configure output pin as OUTPUT
	CASS_OUT_PORT &= ~(_BV(CASS_OUT_PIN)); // Initialize output pin to LOW
}

/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by Timer2               */
/* Wakes AVR from Power Sleep mode.                        */
/*---------------------------------------------------------*/
ISR(TIMER2_COMPA_vect)
{
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
	// check for button presses
	if ((keys_changed_bitmap & _BV(START_STOP_KEY)) && (~keys_bitmap & _BV(START_STOP_KEY)))
	{
		keys_changed_bitmap &= ~_BV(START_STOP_KEY);
		select_key_pressed = true;
	}
	// check for adjustment (rotary encoder)
	if (keys_changed_bitmap & _BV(ROTARY_A))
	{
		keys_changed_bitmap &= ~_BV(ROTARY_A);
		if (!(keys_bitmap & _BV(ROTARY_A))) // A changed to L
		{
			if (keys_bitmap & _BV(ROTARY_B)) // and B is H
			{
				display_task=UP;
			}
		}
	}
	if (keys_changed_bitmap & _BV(ROTARY_B))
	{
		keys_changed_bitmap &= ~_BV(ROTARY_B);
		if (!(keys_bitmap & _BV(ROTARY_B))) // B changed to L
		{
			if (keys_bitmap & _BV(ROTARY_A)) // and A is H
			{
				display_task=DOWN;
			}
		}
	}
	handle_keys();
}

static
void timer2_init (void)
{
	/* Start 100Hz system timer with TC0 */
	OCR2A = F_CPU / 1024 / 100 - 1; // OC reg A
	TCCR2A = _BV(WGM01); // CTC mode -> TOP is OCR2A
	TCCR2B = 0b101; // 1024 prescaler
	TIMSK2 = _BV(OCIE2A); // int at OC match A
}

// sends the specified bit using Timer0
// blocks until the bit is sent only if bit_type!=SPACE
// this gives us time to reload buffer and do computation while sending the space
static void send_bit(BIT_TYPE bit_type)
{
	send_state = FIRST_HALF;
	switch(bit_type)
	{
	case SPACE:
		OCR0A = F_CPU / 1024 / 571 / 2;
		break;
	case ONE:
		OCR0A = F_CPU / 1024 / 1087 / 2;
		break;
	case ZERO:
		OCR0A = F_CPU / 1024 / 2000 / 2;
		break;
	}
	TCNT0 = 0; // reset timer
	TIMSK0 = _BV(OCIE0A); // allow OCA interrupt generation
	CASS_OUT_PORT |= _BV(CASS_OUT_PIN);
	TCCR0B = 0b101; // start timer0 with 1024 prescaler >= 7812Hz for F_CPU=8MHz
	while (bit_type != SPACE && send_state != DONE)
	{
		// block until bit is sent
	}
}

// sends out a byte
// LSB first!
static void send_byte(uint8_t byte)
{
	while (send_state != DONE)
	{
		// wait until the previous SPACE is completed
	}
	uint8_t mask = 1;
	for (int i = 0; i < 8; i++)
	{
		if (mask & byte)
		{
			send_bit(ONE);
		}
		else
		{
			send_bit(ZERO);
		}
		mask <<= 1;
	}
	send_bit(SPACE); // this doesn't block!
}

UINT bytes_read = 0;
uint8_t block_len = 128;
bool has_checksum = false;
bool is_basic = false;

static bool load_first_block_and_check_type()
{
	block_len = 129;
	start_buf_ptr = buf;
	if (Finfo.fsize < 128) //this doesnt make sense.
		return false;
	fr = f_open(&fhdl, Finfo.fname, FA_READ | FA_OPEN_EXISTING);
	if (fr != FR_OK)
	{
		put_rc(fr);
		_delay_ms(500);
		f_close(&fhdl);
		return false;
	}
	// check for TAP header and guess existence of blocknumbers
	fr = f_read(&fhdl, buf, TAP_HEADER_LEN, &bytes_read);
	if (bytes_read != TAP_HEADER_LEN)
	{
		return false;
	}
	if (strncmp_P((char*)buf,tap_header_str,bytes_read))
	{
		// No TAP header
		if (Finfo.fsize % 129) // one block is 1 byte blocknr + 128byte data
		{
			block_len = 128;
			start_buf_ptr = buf + 1;
		}
		// No TAP header found in file -> rewind
		fr = f_lseek(&fhdl, 0);
		if (fr != FR_OK)
		{
			put_rc(fr);
			_delay_ms(500);
			f_close(&fhdl);
			return false;
		}
		// load the first block completely
		fr = f_read(&fhdl, start_buf_ptr, block_len, &bytes_read);
		if (fr != FR_OK)
		{
			put_rc(fr);
			_delay_ms(500);
			f_close(&fhdl);
			return false;
		}
		// check if BASIC header
		// check if MC header
		// check for extension SSS -> headerless BASIC files
		// none of the above so it is RAW
	}
	else
	{
		// it is definitely TAP format which always has blocknumbers
		// and doesnt need any other special recognition procedure
		// load the first block after the header
		fr = f_read(&fhdl, start_buf_ptr, block_len, &bytes_read);
		if (fr != FR_OK)
		{
			put_rc(fr);
			_delay_ms(500);
			f_close(&fhdl);
			return false;
		}
	}
	// print file type on LCD
	return true;
}

static void send_file()
{
	if (load_first_block_and_check_type())
	{
		do
		{
			// calculate checksum
			buf[129] = 0;
			for (int i = 1; i < 129; i++)
			{
				buf[129] += buf[i];
			}
			// Send "Vorton"
			switch (buf[0])
			{
				case 0:
					for (int j = 0; j < 6000; j++)
						send_bit(ONE);
					send_bit(SPACE);
					break;
				case 255:
					for (int j = 0; j < 5296; j++)
						send_bit(ONE);
					send_bit(SPACE);
					break;
				default:
					for (int j = 0; j < 160; j++)
						send_bit(ONE);
					send_bit(SPACE);
					break;
			}
			// send the block
			for (int i = 0; i<130; i++)
			{
				send_byte(buf[i]);
			}
			// read the next block
			fr = f_read(&fhdl, start_buf_ptr, block_len, &bytes_read);
			if (fr != FR_OK)
			{
				put_rc(fr);
				_delay_ms(500);
				f_close(&fhdl);
				return;
			}
		}
		while (bytes_read == block_len);
		send_bit(SPACE); // Just to clean up
		f_close(&fhdl);
	}

}

static void display_fileinfo()
{
		lcd_clrscr();
		xprintf(PSTR("%s"),	Finfo.fname);
		lcd_gotoxy(0,1);
		if (Finfo.fattrib & AM_DIR) {
			xprintf(PSTR("[DIR]"));
		}
		else
		{
			xprintf(PSTR("%d"),	Finfo.fsize);
		}
}

static void display_next()
{
	if (dir_idx < UINT16_MAX)
	{
		f_readdir(&Dir,&Finfo);
	}
	if (!Finfo.fname[0])
	{
		return;
	}
	else
	{
		if (dir_idx < UINT16_MAX)
		{
			dir_idx++;
		}
		display_fileinfo();
	}
}

static void display_prev()
{
	if (dir_idx > 0)
	{
		f_closedir(&Dir);
		f_opendir(&Dir,"/");
		for (uint16_t i=0;i<dir_idx;i++)
		{
			f_readdir(&Dir,&Finfo);
		}
		dir_idx--;
		display_fileinfo();
	}

}

/************************************************************************/
/* To be called at the very beginning                                   */
/************************************************************************/
static void power_save_config()
{
	// ports are configured as input by default.
	// this enables the pullups.
	PORTB = 0xFF;
	PORTC = 0xFF;
	PORTD = 0xFF;
	power_twi_disable();
	power_adc_disable();
	power_timer1_disable();
	power_usart0_disable();
	set_sleep_mode(SLEEP_MODE_IDLE);
	//set_sleep_mode(SLEEP_MODE_PWR_SAVE);
	sleep_bod_disable();
	sleep_enable();
}

int main(void)
{
	power_save_config();
	TIMER_OVF_MONITOR_DDR |= _BV(TIMER_OVF_MONITOR_BIT);
	TIMER_OVF_MONITOR_PORT &= ~_BV(TIMER_OVF_MONITOR_BIT);
	timer0_init();
	timer2_init();				/* Initialize port settings and start system timer process */
	lcd_init(LCD_DISP_ON);
	xdev_out(lcd_putc);
	keys_init();
	sei();
	do 
	{
		fr = f_mount(&FatFs, "", 1);
		if (fr != FR_OK)
		{
			put_rc(fr);
			_delay_ms(500);
		}
	} 
	while (fr != FR_OK);

	fr = f_opendir(&Dir, "/");
	if (fr) {
		put_rc(fr);
	}
	display_next();
	dir_idx = 0;
	if (!Finfo.fname[0])
	{
		lcd_clrscr();
		xprintf(PSTR("[Empty Dir]"));
	}
	
	while(1)
	{
		switch(display_task)
		{
		case UP:
			display_prev();
			display_task=STAY;
			break;
		case DOWN:
			display_next();
			display_task=STAY;
			break;
		case STAY:
			break;
		}
		if (select_key_pressed)
		{
			send_file();
			while(send_state!=DONE)
			{
				// wait for finish before going to sleep
			}
			select_key_pressed = false;
		}
		sleep_cpu();
	}
	
}